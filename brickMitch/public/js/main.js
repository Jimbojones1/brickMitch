// canvas is automatically generated by the framework, null tells phaser to create its own canvas
let ball;
let paddle;
let bricks;
let newBrick;
let brickInfo;
let lifeLostText;
let score = 0;
let lives = 3;


const livesBoard = document.getElementById('Lives');
const scoreBoard = document.getElementById('Score');


const updateScore = () => {
  console.log(typeof  scoreBoard.innerText)
  scoreBoard.innerText = parseInt(scoreBoard.innerText) + 10;
}

const updateLives = () => {
  livesBoard.innerText = lives;
}

const checkLives = () => {
  let countRemaining = 0;
  for (let i = 0; i < bricks.children.length; i++){
    if(bricks.children[i].alive === true){
      countRemaining++
    }
  }

  if (countRemaining === 0){
    alert('you passed this level')
  }


}

const preload = () => {
  game.scale.scaleMode             = Phaser.ScaleManager.SHOW_ALL;
  game.scale.pageAlignHorizontally = true;
  game.scale.pageAlignVertically   = true;
  game.stage.backGroundColor = '#eee';
  // first argument should be same as the variable
  game.load.image('ball', 'img/ball.png');
  game.load.image('paddle', 'img/paddle.png');
  game.load.image('brick', 'img/brick.png');
}

const create = () => {
    game.physics.startSystem(Phaser.Physics.ARCADE);
    game.physics.arcade.checkCollision.down = false;
    ball = game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
    ball.anchor.set(0.5);
    game.physics.enable(ball, Phaser.Physics.ARCADE);
    ball.body.velocity.set(150, -150);
    ball.body.collideWorldBounds = true;
    ball.body.bounce.set(1);
    ball.checkWorldBounds = true;
    ball.events.onOutOfBounds.add(ballOutScreen);

    paddle = game.add.sprite(game.world.width*0.5, game.world.height-5, 'paddle');
    paddle.anchor.set(0.5,1);
    game.physics.enable(paddle, Phaser.Physics.ARCADE);
    paddle.body.immovable = true;
    let textStyle =  { font: '18px Arial', fill: '#0095dd'}
    lifeLostText = game.add.text(game.world.width*0.5, game.world.height*0.5, 'Mitch is bummed out, click to inspire Paul Ryan again', textStyle);
    lifeLostText.anchor.set(0.5);
    lifeLostText.visible = false;
    initBricks();
}

const ballOutScreen = () => {
  lives--
  if(lives){
    updateLives()
    lifeLostText.visible = true;
    ball.reset(game.world.width*0.5, game.world.height-25);
    paddle.reset(game.world.width*0.5, game.world.height-5);
    game.input.onDown.addOnce(() => {
      lifeLostText.visible = false;
      ball.body.velocity.set(150, -150);
    })
  } else {
    alert('game over woman');
    location.reload();
  }
}



const update = () => {
  game.physics.arcade.collide(ball, paddle);
  game.physics.arcade.collide(ball, bricks, ballHitBrick);
  paddle.x = game.input.x || game.world.width*0.5;
}

const ballHitBrick = (ball, brick) => {
  brick.kill();
  updateScore();
  checkLives();
}

const initBricks = () => {
  brickInfo = {
    width: 50,
    height: 20,
    count: {
      row: 1,
      col: 1
    },
    offset: {
      top: 30,
      left: 60
    },
    padding: 10
  }

  bricks = game.add.group();

  for (let c = 0; c < brickInfo.count.col; c++){
    for (let r = 0; r < brickInfo.count.row; r++){
      const brickX = (r * (brickInfo.width + brickInfo.padding)) + brickInfo.offset.left;
      const brickY = (c * (brickInfo.height + brickInfo.padding)) + brickInfo.offset.top;
      newBrick = game.add.sprite(brickX, brickY, 'brick');
      game.physics.enable(newBrick, Phaser.Physics.ARCADE);
      newBrick.anchor.set(0.5);
      newBrick.body.immovable = true;
      bricks.add(newBrick)
    }
  }
}


const game = new Phaser.Game(480, 320, Phaser.AUTO, null, {
  preload: preload, create: create, update: update
});


