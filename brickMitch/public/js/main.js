// canvas is automatically generated by the framework, null tells phaser to create its own canvas
let ball;
let paddle;
let bricks;
let newBrick;
let brickInfo;


const preload = () => {
  game.scale.scaleMode             = Phaser.ScaleManager.SHOW_ALL;
  game.scale.pageAlignHorizontally = true;
  game.scale.pageAlignVertically   = true;
  game.stage.backGroundColor = '#eee';
  // first argument should be same as the variable
  game.load.image('ball', 'img/ball.png');
  game.load.image('paddle', 'img/paddle.png');
  game.load.image('brick', 'img/brick.png');
}

const create = () => {
    game.physics.startSystem(Phaser.Physics.ARCADE);
    game.physics.arcade.checkCollision.down = false;
    ball = game.add.sprite(game.world.width*0.5, game.world.height-25, 'ball');
    ball.anchor.set(0.5);
    game.physics.enable(ball, Phaser.Physics.ARCADE);
    ball.body.velocity.set(150, -150);
    ball.body.collideWorldBounds = true;
    ball.body.bounce.set(1);
    ball.checkWorldBounds = true;
    ball.events.onOutOfBounds.add(function(){
        alert('Game over!');
        location.reload();
    }, this);

    paddle = game.add.sprite(game.world.width*0.5, game.world.height-5, 'paddle');
    paddle.anchor.set(0.5,1);
    game.physics.enable(paddle, Phaser.Physics.ARCADE);
    paddle.body.immovable = true;

    initBricks();
}

const update = () => {
  game.physics.arcade.collide(ball, paddle);
  game.physics.arcade.collide(ball, bricks, ballHitBrick);
  paddle.x = game.input.x || game.world.width*0.5;
}

const ballHitBrick = (ball, brick) => {
  brick.kill();
}

const initBricks = () => {
  brickInfo = {
    width: 50,
    height: 20,
    count: {
      row: 7,
      col: 3
    },
    offset: {
      top: 30,
      left: 60
    },
    padding: 10
  }

  bricks = game.add.group();

  for (let c = 0; c < brickInfo.count.col; c++){
    for (let r = 0; r < brickInfo.count.row; r++){
      const brickX = (r * (brickInfo.width + brickInfo.padding)) + brickInfo.offset.left;
      const brickY = (c * (brickInfo.height + brickInfo.padding)) + brickInfo.offset.top;
      newBrick = game.add.sprite(brickX, brickY, 'brick');
      game.physics.enable(newBrick, Phaser.Physics.ARCADE);
      newBrick.anchor.set(0.5);
      newBrick.body.immovable = true;
      bricks.add(newBrick)
    }
  }


}


const game = new Phaser.Game(480, 320, Phaser.AUTO, null, {
  preload: preload, create: create, update: update
});


